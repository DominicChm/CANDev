/** can.h
 * CAN framework to reduce boilerplate while remaining reasonably efficient.
 *
 * NOTE THAT this looks like it does because great pains have been taken
 * to ensure that CAN mappings (address -> data pointer), which might otherwise
 * take up lots of SRAM, are stored statically IN FLASH.
 */

#ifndef LIB_CAN_H
#define LIB_CAN_H
#include <Arduino.h>
#include <addr.h>

#define CAN_ADDR_MAX 0xFFFF
#define MAX_INTERFACES 64

/**
 * Generic struct representing a CAN message.
 * Should be generated by a HAL in the future
 */
struct canmsg_t {
    uint32_t address;
    size_t size;
    uint8_t data[8];

    operator bool() { return address || size; }
};

/**
 * Contains a pointer to some data, as well as the size of said data.
 * User-defined either manually and/or using the provided `link()` helper.
 * Fed into the CANMappings.
 *
 * Example usage:
 * ```
 * double randomval = 0;
 * can_mapping_t { &random_value, sizeof(random_value) }
 * ```
 */
struct can_mapping_t {
    void* data;
    uint8_t size;
};

/**
 * Helper to create a can_mapping_t from
 * a variable reference, without needing to repeat the field
 * or "sizeof". Uses CPP template deduction with sizeof.
 */
template <typename T>
constexpr can_mapping_t link(T& data) {
    static_assert(sizeof(T) <= 64, "CAN data types must be less than 64 bytes large");
    return can_mapping_t{&data, sizeof(T)};
}

// HAL functions - implementation varies.
bool can_hal_begin();
bool can_hal_available();
canmsg_t can_hal_read();
void can_hal_write(canmsg_t *msg);

/**
 * Wraps mappings (CAN address -> data pointer) in a generic way.
 * Allows module mappings to be used by multiple interfaces without
 * needing to redefine pointers to data.
 *
 * IMPORTANT: THE OFFSET OF A VALUE'S CAN ADDRESS IS DEFINED BY ITS INDEX IN THE MAPPINGS ARRAY
 *
 * base_struct - Ptr to the struct mapped pointers are within. Used to create offsets
 * mappings - array of can_mapping_t
 */
class CANMappings {
   public:
    const void* map_root;
    const can_mapping_t* mappings;
    const size_t num_mappings;

    template <size_t NMappings>  // Template magic eliminates size boilerplate
    CANMappings(const void* map_source, const can_mapping_t (&mappings)[NMappings]);

    /**
     *  Converts a CAN address offset to a pointer to the data it maps to.
     */
    void* resolve_address_data_ptr(void* data_root, uint32_t address_offset);

    size_t size_at_address(uint32_t offset);

    void* resolve_mapping_ptr(void* data_root, const can_mapping_t* mapping);
};

/**
 * Links the CAN HAL and mappings, at a specific address
 */
class CANInterface {
    CANMappings& mappings;
    const size_t base_address;
    void* data;

   public:
    template <typename TData>
    CANInterface(const uint32_t base_address, TData& data, CANMappings& mappings);

    /**
     * Checks whether an address falls within the range this CANInterface can
     * handle.
     *
     * This range is defined as [BASE ADDRESS, BASE ADDRESS + Number of mappings]
     */
    bool handles_address(uint32_t incoming_address);

    /**
     * Tries to match an incoming CAN frame to an address
     * this CANInterface controls. If a matching address is found,
     * and the size of the local data matches the incoming frame's size,
     * the CAN frame is directly copied to the local representation.
     *
     * Returns true if the frame was handled, false if not.
     */
    bool try_handle_message(canmsg_t msg);

    /**
     * Transmits the current state of the data controlled by this
     * CANInterface onto the CANBus.
     */
    void transmit(bool packed);
};

namespace can {

// Tracks in-use interfaces.
// Interfaces add themselves to this array when they are constructed.
size_t num_interfaces = 0;
CANInterface* interfaces[MAX_INTERFACES] = {};

bool begin() {
    return can_hal_begin();
}

void loop() {
    if (can_hal_available()) {
        Serial.println("CAN AVAILABLE");
        canmsg_t msg = can_hal_read();

        // Distribute the message to known interfaces until one successfully handles it.
        for (size_t i = 0; i < num_interfaces && !interfaces[i]->try_handle_message(msg); i++)
            ;
    }
}
}  // namespace can

/******************* IMPLEMENTATIONS (yeah in the header deal with it) *******************/
template <typename TData>
CANInterface::CANInterface(const uint32_t base_address, TData& data, CANMappings& mappings) : mappings(mappings), base_address(base_address), data(&data) {
    can::interfaces[can::num_interfaces++] = this;  // Register this interface with the can namespace so that messages are pushed to it.
};

bool CANInterface::handles_address(uint32_t incoming_address) {
    return incoming_address - base_address < mappings.num_mappings;
}

bool CANInterface::try_handle_message(canmsg_t msg) {
    if (!handles_address(msg.address)) return false;

    uint32_t offset = msg.address - base_address;

    //if (mappings.size_at_address(offset) != msg.size) return false;
    Serial.println("CAN MESSAGE HANDLED");
    memcpy(mappings.resolve_address_data_ptr(data, offset), msg.data, msg.size);

    return true;
}

void CANInterface::transmit(bool pack = false) {
    for (size_t i = 0; i < mappings.num_mappings; i++) {
        const can_mapping_t* m = &mappings.mappings[i];

        void* ptr_data = mappings.resolve_mapping_ptr(&data, m);
        canmsg_t msg{
            base_address + i,
            m->size,
        };

        memcpy(&msg.data, ptr_data, m->size);

        can_hal_write(&msg);
    }
}

template <size_t NMappings>
CANMappings::CANMappings(const void* map_source, const can_mapping_t (&mappings)[NMappings]) : map_root(map_source), mappings(mappings), num_mappings(NMappings) {
}

size_t CANMappings::size_at_address(uint32_t offset) {
    if (offset >= num_mappings) return 0;

    return mappings[offset].size;
}

void* CANMappings::resolve_address_data_ptr(void* data_root, uint32_t offset) {
    if (offset >= num_mappings) return 0;

    // Use the provided mappings and their root address to
    // create a corresponding pointer into the passed memory.
    return (void*)((size_t)data_root + (size_t)mappings[offset].data - (size_t)map_root);
}

void* CANMappings::resolve_mapping_ptr(void* data_root, const can_mapping_t* mapping) {
    if (mapping == nullptr) return 0;

    // Use the provided mappings and their root address to
    // create a corresponding pointer into the passed memory.
    return (void*)((size_t)data_root + (size_t)mapping->data - (size_t)map_root);
}
#endif